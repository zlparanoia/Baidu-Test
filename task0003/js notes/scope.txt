JavaScript的作用域链：

作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在js中，变量的作用域有全局作用域和局部作用域两种。

1. 全局作用域：在代码中任何地方都能访问到的对象。
几种拥有全局作用域的情形：
(1)最外层函数和在最外层函数外面定义的变量拥有全局作用域。
(2)所有未定义直接赋值的变量自动声明为拥有全局作用域。
(3)所有window对象的属性拥有全局作用域。

2.局部作用域也叫函数作用域：一般只在固定的代码片段内可访问到。变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。

内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性的、有次序的。

若把执行环境从全局执行环境到局部执行环境向下列举，每个环境都可以向上搜索作用域链，以查询变量和函数名，如果在局部环境中没有找到，则继续沿着作用域链向上搜索，一直搜索到全局环境，如果全局环境也没有，说明变量未声明；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。

作用域链只会被with语句和catch语句影响。
这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含被抛出错误对象的声明。

with语句：
当运行到with语句时，作用域链临时被改变。一个新的可变对象被创建，它包含了参数指定的对象的所有属性，这个对象将被推入作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。因此在程序中应避免使用with语句。
with：主要用来临时扩展作用域链，将语句中的对象添加到作用域的头部。with语句结束后，作用域链恢复正常。
catch:当try代码块中发生错误时，执行过程会跳转到catch语句，然后把异常对象推入一个可变对象并置于作用域的头部。

1.JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。
2.在每次调用一个函数的时候，就会进入一个函数内的作用域，当从函数返回以后，就返回调用前的作用域。
3.Js作用域的实现和c/c++不同，并非用"堆栈"的方式，而是使用列表。
4.c/c++块级作用域与JS的区别： 
在c/c++中，花括号内中的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的。而js没有块级作用域，而是函数作用域。

所以在定义变量和函数表达式之前输出变量相当于声明提前，只是赋值undefined。而函数定义式直接提前。

某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。
全局执行环境直到应用程序退出，例如关闭网页或浏览器时才会被销毁。

作用域链的用途：是保证对执行环境有权访问的所有变量和函数的有序访问。

作用域链： 从最里层的函数作用域开始找变量，如果没有，逐层向外找。

闭包：
由于作用域链，闭包只能取得包含函数中任何变量的最后一个值，闭包所保存的是整个变量对象，而不是某个特殊的值。
它只取最后一个值：
function code() {
          var name = "ddd";
          name = "sss";
          var a = function() {
               return name;
          };
          name = "ppp";
          return a;
     }
     alert(code()());   //ppp

function fn() {
          var arr= [];
          for(var i = 0; i < 3; i++) {
          arr[i] = function() {
               return i;
          };
     }
     return arr;
     }
  console.log(fn()[0]());
     console.log(fn()[1]());
     console.log(fn()[2]());

返回一个函数数组，每个函数对应的值都是3，取i的最后一个值。

     function fn() {
          var arr= [];
          for(var i = 0; i < 3; i++) {
          arr[i] = function(num) {
               return function() {
                    return num;
               } ;
          }(i);      // 立即执行 传值i
     }
     return arr;
     }
     console.log(fn()[0]()); //0
     console.log(fn()[1]());  //1
     console.log(fn()[2]()); //2
将每个i传给num,因为立即执行如果直接return num会直接将数值赋值给arr[i],所以return一个函数再返回数值。

JavaScript的预编译：

1.JS在执行每一段JS代码之前，都会首先处理var关键字和function定义式（函数定义式和函数表达式）。
变量和函数表达式赋值undefined。函数定义式将函数定义提前。
2.JS的预编译是以段为处理单元的。
