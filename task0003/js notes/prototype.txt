JavaScript原型学习笔记

原型：我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含所有实例共享的属性和方法；prototype就是通过调用构造函数创建那个对象实例的原型对象。

原型是一个对象，其他对象可以通过它实现属性继承。

原型链：访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找。

1.js继承：通过prototype模型。
2.属性查找：当查找一个对象的属性时，js会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部，也就是Object.prototype，但是仍然没有找到指定的属性，就会返回undefined。
3.任何一个对象都可以成为原型。
4.所有的对象在默认的情况下都有一个原型，因为原型本身也是对象，所以每个原型自身又有一个原型。
5.每个对象都有一个__proto__属性，指向创建该对象的函数的prototype。
6.对象的__proto__指向的是创建它的函数的prototype。
7.每个函数都有一个prototype属性，每一个对象都有一个隐藏的__proto__属性。
8.Object.prototype的__proto__指向的是null。

一、函数和对象的关系
1、对象都是通过函数创建的。
var obj = {a : 10}; 相当于 var obj = new Object(); obj.a = 10;
对象是函数创建的，函数又是一种对象。

A instanceof B：
instanceof的判断规则：沿着A的__proto__这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，就返回true。如果找到终点还未重合返回false。

二、执行上下文
1、函数每被调用一次，都会产生一个新的执行上下文环境。
2、函数在定义的时候（而不是调用的时候），就已经确定了函数体内部自由变量的作用域。
3、执行上下文：
全局代码的上下文环境数据内容：
普通变量（包括函数表达式）：声明，默认undefined
函数声明：赋值。
this（全局）:赋值。
如果代码段是函数体，那么在此基础上需要附加：
参数：赋值。
arguments：赋值。
自由变量的取值作用域：赋值。
执行上下文定义： 在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值，有的先用undefined占个空。

作用域： js除了全局作用域之外，只有函数可以创建作用域。我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方最好不好出现变量声明，建议用单var形式。

（function(){}()）：自动执行的匿名函数，变量会被限制在一个独立的作用域中，不会与全局作用域或者其他作用域的同名变量产生冲突。

自由变量的取值： 要到创建这个函数的那个作用域中取值。

闭包的两种情况：1、函数作为返回值。2、函数作为参数传递。

执行上下文栈：执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个。

function fn() {
     var max = 10;
     return function bar(x) {
          if (x > max) {
               console.log(x)
          }
     };
}
var f1 = fn(),
      max = 100;
f1(15);

fn()调用完成时，按理说应该销毁fn()的执行上下文环境，但是这里不能这么做。因为执行fn()时，返回的是一个函数，函数的特别之处在于可以创建一个独立的作用域。返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。

